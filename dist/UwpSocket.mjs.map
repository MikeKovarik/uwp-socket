{"version":3,"file":"UwpSocket.mjs","sources":["../lib/util.js","../lib/UwpSocket.js"],"sourcesContent":["var errorCodes = {\r\n\t'-2147014835': 'ECONNREFUSED',\r\n\t'-2147013895': 'ENOENT',\r\n\t// (Address already in use): An attempt to bind a server (net, http, or https) to a local address failed due to another server on the local system already occupying that address.\r\n\t'-2147014848': 'EADDRINUSE',\r\n\t'-2147014836': 'ETIMEDOUT',\r\n\t// TODO (Connection refused): No connection could be made because the target machine actively refused it. \r\n\t'?': 'ECONNREFUSED',\r\n\t// TODO EINVAL The socket is already connected.\r\n\t'?': 'EINVAL',\r\n\t// (Connection reset by peer): A connection was forcibly closed by a peer. \r\n\t'-2147014842': 'ECONNRESET'\r\n\t//EACCES (Permission denied): An attempt was made to access a file in a way forbidden by its file access permissions.\r\n}\r\n\r\nexport function errnoException(err, syscall, address, port) {\r\n\tvar errname;\r\n\tvar message;\r\n\tif (typeof err == 'object') {\r\n\t\terrname = errorCodes[err.number] || err.number;\r\n\t\tmessage = syscall + ' ' + errname + ' ' + err.message;\r\n\t} else {\r\n\t\terrname = err;\r\n\t\tmessage = syscall + ' ' + errname;\r\n\t}\r\n\tvar e = new Error(message);\r\n\te.code = e.errno = errname;\r\n\te.syscall = syscall;\r\n\tif (port) {\r\n\t\te.port = port;\r\n\t}\r\n\tif (address) {\r\n\t\te.address = address;\r\n\t}\r\n\treturn e;\r\n}\r\n","import {Buffer} from 'buffer'\r\nimport {Duplex} from 'stream'\r\n//import {process} from 'process'\r\nimport {errnoException} from './util'\r\n\r\n\r\nvar Streams = Windows.Storage.Streams\r\nvar DataWriter = Streams.DataWriter\r\nvar DataReader = Streams.DataReader\r\n\r\nexport default class UwpSocket extends Duplex {\r\n\r\n\t// exporting as static on class due to limitations of UMD format\r\n\t// to which this project compiles (until ESM is widely available)\r\n\tstatic errnoException = errnoException\r\n\r\n\t_connecting = false\r\n\t_connected = false\r\n\tdestroyed = false\r\n\t_hadError = false\r\n\t// 64kB\r\n\t_maxChunkLength = 65536\r\n\t// this is the UWP StreamSocket \r\n\t_handle = null\r\n\r\n\tconstructor(...args) {\r\n\t\tsuper(...args)\r\n\r\n\t\tthis._onConnect = this._onConnect.bind(this)\r\n\t\tthis._readChunk = this._readChunk.bind(this)\r\n\t\tthis._onRead = this._onRead.bind(this)\r\n\r\n\t\t// shut down the socket when we're finished with it.\r\n\t\tthis.on('finish', this.destroy)\r\n\r\n\t\tthis._initSocketHandle()\r\n\t}\r\n\r\n\t_initSocketHandle() {\r\n\t\tthis.readable = false\r\n\t\tthis.writable = false\r\n\t\tthis.destroyed = false\r\n\t\tthis.bytesRead = 0\r\n\t\tthis._bytesWritten = 0\r\n\t\tthis._hadError = false\r\n\t}\r\n\r\n\tconnect(cb) {\r\n\t\tthis._initSocketHandle()\r\n\r\n\t\tif (typeof cb === 'function') \r\n\t\t\tthis.once('connect', cb)\r\n\r\n\t\tthis._connecting = true\r\n\t\tthis.writable = true\r\n\t}\r\n\r\n\t_onConnect() {\r\n\t\t// .destroy() might have been called in meantime (right after .connect() but before connection was established)\r\n\t\tif (this.destroyed) return\r\n\t\t// setup state\r\n\t\tthis._connecting = false\r\n\t\tthis._connected = true\r\n\t\t// setup writer and writer. it needs to be ready to use in connect callback\r\n\t\tthis._writer = new DataWriter(this._handle.outputStream)\r\n\t\tthis.writable = true\r\n\t\tthis._reader = new DataReader(this._handle.inputStream)\r\n\t\tthis.readable = true\r\n\t\t// Make _reader.loadAsync read any ammount of bytes (basically right when any data arrive)\r\n\t\t// In other words: wont't wait for receiving all of the _maxChunkLength to call _onRead\r\n\t\tthis._reader.inputStreamOptions = Windows.Storage.Streams.InputStreamOptions.partial\r\n\t\t// emit connect, at this point everything should be ready to write\r\n\t\tthis.emit('connect')\r\n\t\t// start listening only after emiting connect, 'data' event can't preceed 'connect'\r\n\t\tthis._readChunk()\r\n\t\t// start the first read, or get an immediate EOF.\r\n\t\t// this doesn't actually consume any bytes, because len=0.\r\n\t\tthis.read(0)\r\n\t}\r\n\r\n\t_readChunk() {\r\n\t\tif (!(this._reader && this.readable)) return\r\n\t\t// sets up data listener and calls _onRead if (what a surprise) data is received\r\n\t\tthis._reader\r\n\t\t\t.loadAsync(this._maxChunkLength)\r\n\t\t\t.done(this._onRead, err => this._onError(err, 'read'))\r\n\t}\r\n\r\n\t_onRead(chunkBytesRead) {\r\n\t\tif (chunkBytesRead == 0) {\r\n\t\t\t// server closed this socket, destroy this end too\r\n\t\t\tthis.end()\r\n\t\t\treturn\r\n\t\t}\r\n\t\tthis.bytesRead += chunkBytesRead\r\n\t\t// received some data, load the into Node-like Buffer (Uint8 typed array) and emit\r\n\t\tvar buffer = new Buffer(chunkBytesRead)\r\n\t\t// read data from DataReder into given buffer array\r\n\t\tthis._reader.readBytes(buffer)\r\n\t\tthis.push(buffer)\r\n\t\t// TODO: apply backpressure (pause receiving data) if push returns false\r\n\t\t// keep receiving next data\r\n\t\tsetImmediate(this._readChunk)\r\n\t}\r\n\r\n\t_onError(err, syscall, address, port) {\r\n\t\t// TODO investigate - should multiple errors be merged into one?\r\n\t\t// probable case - .end() during both reading and writing will (maybe) cause two errors? just a thought thou...\r\n\r\n\t\t// probably just some error of not finished read/write due to calling cancelIOAsync in .end()\r\n\t\tif (this.destroyed) return\r\n\t\tthis._connecting = false\r\n\t\tthis._hadError = true\r\n\t\t//process.nextTick(connectErrorNT, this, errnoException(err, syscall, address, port))\r\n\t\t//process.nextTick(() => {\r\n\t\tsetImmediate(() => {\r\n\t\t\tthis.emit('error', errnoException(err, syscall, address, port))\r\n\t\t\tthis.destroy()\r\n\t\t})\r\n\t}\r\n\r\n\r\n\t//////////////////////////////// END & DESTROY ////////////////////////////////////////\r\n\r\n\tend(data, encoding) {\r\n\t\tif (!this._connecting && !this._connected) {\r\n\t\t\t// .end() was called before .connect() do nothing\r\n\t\t\t// Duplex.prototype.write has to be called to ensure throwing error (write after end)\r\n\t\t\tDuplex.prototype.end.call(this, data, encoding)\r\n\t\t\treturn\r\n\t\t}\r\n\t\tif (this._connecting) {\r\n\t\t\tthis.once('connect', () => this.end(data, encoding))\r\n\t\t\t//setImmediate(() => this.end(data, encoding))\r\n\t\t\treturn\r\n\t\t}\r\n\t\t// Duplex.prototype.write has to be called to ensure throwing error (write after end)\r\n\t\t// WARNING: Duplex.end() calls this.destroy\r\n\t\tDuplex.prototype.end.call(this, data, encoding)\r\n\t\tthis._willEmitEnd = true\r\n\t\tif (this.readable && !this._readableState.endEmitted) {\r\n\t\t\tthis.read(0)\r\n\t\t}\r\n\t}\r\n\r\n\tdestroy(exception, cb) {\r\n\t\t// .destroy() called before .connect() do nothing\r\n\t\tif (!this._connecting && !this._connected) return\r\n\r\n\t\tvar fireErrorCallbacks = () => {\r\n\t\t\tif (cb) cb(exception)\r\n\t\t\tif (exception && !this._writableState.errorEmitted) {\r\n\t\t\t\t//process.nextTick(emitErrorNT, this, new Error(exception))\r\n\t\t\t\tsetImmediate(() => this.emit('error', new Error(exception)))\r\n\t\t\t\t//setImmediate(() => this.emit('error', new Error(exception)))\r\n\t\t\t\tthis._writableState.errorEmitted = true\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// already destroyed, fire error callbacks\r\n\t\tif (this.destroyed) return fireErrorCallbacks()\r\n\r\n\t\t// stream is no more readable (won't be sending anything to server)\r\n\t\t// but it remains readable since some data from server might be already\r\n\t\t// on the way or in buffer waiting to be emitted\r\n\t\tthis.writable = false\r\n\t\t// calling destroy with argument causes error and 'close' event callback argument to be true\r\n\t\tthis._hadError = this._hadError || !!exception\r\n\t\t// we set destroyed to true before firing error callbacks in order\r\n\t\t// to make its re-entrance safe in case Socket.prototype.destroy()\r\n\t\t// is called within callbacks\r\n\t\tthis.destroyed = true\r\n\t\tfireErrorCallbacks()\r\n\t\tthis._connecting = false\r\n\t\tthis._connected = false\r\n\r\n\t\tthis._destroyHandle()\r\n\t}\r\n\t_destroyHandle() {\r\n\t\t// why the setImmediate?\r\n\t\t// cancelIOAsync might call the callback synchronously if there's no pending read/write\r\n\t\t// but it needs to be async - to properly react to errors (Error: write after end).\r\n\t\t// Also .end() (unlike .destroy() ) gives reader/writer some head start to finish reading.\r\n\t\t// Writer has to stop sending whatever is in buffer and send FIN packet to gracefuly close connection. \r\n\t\tsetImmediate(() => {\r\n\t\t\tif (this._handle == null) return\r\n\t\t\t// disabling readable here instead of in _destroyHandle2() to make reading safer\r\n\t\t\t// (to prevent Error reading in inappropriate time)\r\n\t\t\tthis.readable = false\r\n\t\t\t// CancelIOAsync cancels pending writes and reads, but if there is a write buffer pending\r\n\t\t\t// in networking drivers, it flushes the write.\r\n\t\t\tvar _destroyHandle2 = this._destroyHandle2.bind(this)\r\n\t\t\tthis._handle.cancelIOAsync().done(_destroyHandle2, _destroyHandle2)\r\n\t\t\t// TODO investigate - does this need any futher error handling?\r\n\t\t})\r\n\t}\r\n\t_destroyHandle2() {\r\n\t\tif (this._handle) {\r\n\t\t\ttry {\r\n\t\t\t\tthis._handle.close()\r\n\t\t\t} catch(e) {}\r\n\t\t\tthis._handle = null\r\n\t\t}\r\n\t\tif (this._writer) {\r\n\t\t\t// might be writing at the moment\r\n\t\t\ttry {\r\n\t\t\t\tthis._writer.detachStream()\r\n\t\t\t} catch(e) {}\r\n\t\t\t// TODO invesitagate - does this need any further error handling? Or will the writer just burn in flames on it's own?\r\n\t\t\tthis._writer = null\r\n\t\t}\r\n\t\tif (this._reader) {\r\n\t\t\t// might be reading at the moment\r\n\t\t\ttry {\r\n\t\t\t\tthis._reader.detachStream()\r\n\t\t\t} catch(e) {}\r\n\t\t\t// TODO invesitagate - does this need any further error handling? Or will the reader just burn in flames on it's own?\r\n\t\t\tthis._reader = null\r\n\t\t}\r\n\r\n\t\tif (this._willEmitEnd && !this._readableState.endEmitted) {\r\n\t\t\t// either we closed the socket or server disconnected us and WinRT didn't give us EOF\r\n\t\t\t// so we have to simulate it by pushing null to data. (in other word: this emits 'end')\r\n\t\t\tthis.push(null)\r\n\t\t\tthis.once('end', () => this.emit('close', this._hadError))\r\n\t\t} else {\r\n\t\t\tthis.emit('close', this._hadError)\r\n\t\t}\r\n\r\n\t}\r\n\r\n\r\n\t//////////////////////////////// READ / WRITE ////////////////////////////////////////\r\n\r\n\tget bufferSize() {\r\n\t\t// returns undefined before socket.connect()\r\n\t\tif (this._connecting || this._connected)\r\n\t\t\treturn this._writableState.length\r\n\t}\r\n\r\n\t// The amount of received bytes.\r\n\tbytesRead = 0\r\n\t\r\n\t// The ammount of bytes sent\r\n\tget bytesWritten() {\r\n\t\treturn this._bytesWritten + (this.bufferSize || 0)\r\n\t}\r\n\t_bytesWritten = 0\r\n\r\n\t_write(chunk, encoding, done) {\r\n\t\tif (!done) done = () => {}\r\n\r\n\t\tif (this._connecting) {\r\n\t\t\tthis.once('connect', () => this._write(chunk, encoding, done))\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tif (this.writable) {\r\n\t\t\tthis._writer.writeBytes(chunk)\r\n\t\t\t// note: don't pass callback as rference! oh boy those contexts...\r\n\t\t\tthis._writer.storeAsync().done(() => {\r\n\t\t\t\tthis._bytesWritten += chunk.length\r\n\t\t\t\tdone()\r\n\t\t\t}, err => this._onError(err, 'write'))\r\n\t\t} else {\r\n\t\t\tdone(new Error('This socket is closed'))\r\n\t\t}\r\n\t}\r\n\r\n\t_read(n) {}\r\n\r\n\r\n}\r\n"],"names":["errorCodes","errnoException","err","syscall","address","port","errname","message","number","e","Error","code","errno","Streams","Windows","Storage","DataWriter","DataReader","UwpSocket","args","_connecting","_connected","destroyed","_hadError","_maxChunkLength","_handle","bytesRead","_bytesWritten","_onConnect","bind","_readChunk","_onRead","on","destroy","_initSocketHandle","readable","writable","cb","once","_writer","outputStream","_reader","inputStream","inputStreamOptions","InputStreamOptions","partial","emit","read","loadAsync","done","_onError","chunkBytesRead","end","buffer","Buffer","readBytes","push","data","encoding","prototype","call","_willEmitEnd","_readableState","endEmitted","exception","fireErrorCallbacks","_writableState","errorEmitted","_destroyHandle","_destroyHandle2","cancelIOAsync","close","detachStream","chunk","_write","writeBytes","storeAsync","length","n","bufferSize","Duplex"],"mappings":"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"}